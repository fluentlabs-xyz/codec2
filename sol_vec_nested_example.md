[
0,0,0,4,  - смещение к первому элементу
0,0,0,2,  - длина первого вектора (2 элемента)
0,0,0,8,  - смещение ко второму элементу
0,0,0,16, - смещение к третьему элементу

0,0,0,3,  - длина второго вектора (3 элемента)
0,0,0,1,  - первый элемент второго вектора
0,0,0,2,  - второй элемент второго вектора
0,0,0,3,  - третий элемент второго вектора
0,0,0,2,  - длина третьего вектора (2 элемента)
0,0,0,1,  - первый элемент третьего вектора
0,0,0,2   - второй элемент третьего вектора
]

## Вопросы

- Как отличить вложенный массив от обычного?
  - Реализовать трейт Encoder отдельно для вложенного массива

  - Проверять значение - если это смещение, то значение должно быть кратно ALIGN и не должно превышать оставшееся место в буфере offset < buf.remaining() - ALIGN
    - такой подход накладывает ограничение на используемый буфер - мы предполагаем, что от переданного offset до конца буфера записаны только данные вложенного массива

## solidity abi encoded nested arr

let original: Vec<Vec<u32>> = vec![vec![1u32, 2, 3], vec![4, 5]];

0000000000000000000000000000000000000000000000000000000000000020
0000000000000000000000000000000000000000000000000000000000000002
0000000000000000000000000000000000000000000000000000000000000040
00000000000000000000000000000000000000000000000000000000000000c0
0000000000000000000000000000000000000000000000000000000000000003
0000000000000000000000000000000000000000000000000000000000000001
0000000000000000000000000000000000000000000000000000000000000002
0000000000000000000000000000000000000000000000000000000000000003
0000000000000000000000000000000000000000000000000000000000000002
0000000000000000000000000000000000000000000000000000000000000004
0000000000000000000000000000000000000000000000000000000000000005
